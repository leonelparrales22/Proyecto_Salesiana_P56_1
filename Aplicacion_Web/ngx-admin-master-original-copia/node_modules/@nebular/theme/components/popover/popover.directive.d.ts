/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { AfterViewInit, ElementRef, OnChanges, OnDestroy, OnInit, EventEmitter } from '@angular/core';
import { NbDynamicOverlay, NbDynamicOverlayController } from '../cdk/overlay/dynamic/dynamic-overlay';
import { NbDynamicOverlayHandler } from '../cdk/overlay/dynamic/dynamic-overlay-handler';
import { NbAdjustment, NbPosition, NbPositionValues } from '../cdk/overlay/overlay-position';
import { NbOverlayContent } from '../cdk/overlay/overlay-service';
import { NbTrigger, NbTriggerValues } from '../cdk/overlay/overlay-trigger';
import { NbPopoverComponent } from './popover.component';
import { Subject } from 'rxjs';
/**
 * Powerful popover directive, which provides the best UX for your users.
 *
 * @stacked-example(Showcase, popover/popover-showcase.component)
 *
 * Popover can accept different content such as:
 * TemplateRef
 *
 * ```html
 * <button [nbPopover]="templateRef"></button>
 * <ng-template #templateRef>
 *   <span>Hello, Popover!</span>
 * </ng-template>
 * ```
 * ### Installation
 *
 * Import `NbPopoverModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbPopoverModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Custom components
 *
 * ```html
 * <button [nbPopover]="MyPopoverComponent"></button>
 * ```
 *
 * Both custom components and templateRef popovers can receive *contentContext* property
 * that will be passed to the content props.
 *
 * Primitive types
 *
 * ```html
 * <button nbPopover="Hello, Popover!"></button>
 * ```
 *
 * Popover has different placements, such as: top, bottom, left, right, start and end
 * which can be used as following:
 *
 * @stacked-example(Placements, popover/popover-placements.component)
 *
 * By default popover will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the popover container.
 * If you want to disable this behaviour set it `noop`.
 *
 * ```html
 * <button nbPopover="Hello, Popover!" nbPopoverAdjustment="noop"></button>
 * ```
 *
 * Popover has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, popover/popover-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, popover/popover-noop.component)
 *
 * Below are examples for manual popover settings control, both via template binding and code.
 * @stacked-example(Popover Settings, popover/popover-dynamic.component)
 *
 * Please note, while manipulating Popover setting via code, you need to call `rebuild()` method to apply the settings
 * changed.
 * @stacked-example(Popover Settings Code, popover/popover-dynamic-code.component)
 *
 * @additional-example(Template Ref, popover/popover-template-ref.component)
 * @additional-example(Custom Component, popover/popover-custom-component.component)
 * */
import * as ɵngcc0 from '@angular/core';
export declare class NbPopoverDirective implements NbDynamicOverlayController, OnChanges, AfterViewInit, OnDestroy, OnInit {
    protected hostRef: ElementRef;
    protected dynamicOverlayHandler: NbDynamicOverlayHandler;
    protected popoverComponent: typeof NbPopoverComponent;
    protected dynamicOverlay: NbDynamicOverlay;
    protected destroy$: Subject<void>;
    /**
     * Popover content which will be rendered in NbArrowedOverlayContainerComponent.
     * Available content: template ref, component and any primitive.
     * */
    content: NbOverlayContent;
    /**
     * Container content context. Will be applied to the rendered component.
     * */
    context: Object;
    /**
     * Position will be calculated relatively host element based on the position.
     * Can be top, right, bottom, left, start or end.
     * */
    position: NbPosition;
    static ngAcceptInputType_position: NbPositionValues;
    /**
     * Container position will be changes automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatically adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     * */
    get adjustment(): NbAdjustment;
    set adjustment(value: NbAdjustment);
    protected _adjustment: NbAdjustment;
    /**
     * Describes when the container will be shown.
     * Available options: `click`, `hover`, `hint`, `focus` and `noop`
     * */
    trigger: NbTrigger;
    static ngAcceptInputType_trigger: NbTriggerValues;
    /**
     * Sets popover offset
     * */
    offset: number;
    popoverClass: string;
    nbPopoverShowStateChange: EventEmitter<{
        isShown: boolean;
    }>;
    get isShown(): boolean;
    constructor(hostRef: ElementRef, dynamicOverlayHandler: NbDynamicOverlayHandler);
    ngOnInit(): void;
    ngOnChanges(): void;
    ngAfterViewInit(): void;
    rebuild(): void;
    show(): void;
    hide(): void;
    toggle(): void;
    ngOnDestroy(): void;
    protected configureDynamicOverlay(): NbDynamicOverlayHandler;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbPopoverDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbPopoverDirective, "[nbPopover]", ["nbPopover"], {
    "context": "nbPopoverContext";
    "position": "nbPopoverPlacement";
    "trigger": "nbPopoverTrigger";
    "offset": "nbPopoverOffset";
    "popoverClass": "nbPopoverClass";
    "adjustment": "nbPopoverAdjustment";
    "content": "nbPopover";
}, {
    "nbPopoverShowStateChange": "nbPopoverShowStateChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsicG9wb3Zlci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIEVsZW1lbnRSZWYsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmJEeW5hbWljT3ZlcmxheSwgTmJEeW5hbWljT3ZlcmxheUNvbnRyb2xsZXIgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9keW5hbWljL2R5bmFtaWMtb3ZlcmxheSc7XG5pbXBvcnQgeyBOYkR5bmFtaWNPdmVybGF5SGFuZGxlciB9IGZyb20gJy4uL2Nkay9vdmVybGF5L2R5bmFtaWMvZHluYW1pYy1vdmVybGF5LWhhbmRsZXInO1xuaW1wb3J0IHsgTmJBZGp1c3RtZW50LCBOYlBvc2l0aW9uLCBOYlBvc2l0aW9uVmFsdWVzIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS1wb3NpdGlvbic7XG5pbXBvcnQgeyBOYk92ZXJsYXlDb250ZW50IH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS1zZXJ2aWNlJztcbmltcG9ydCB7IE5iVHJpZ2dlciwgTmJUcmlnZ2VyVmFsdWVzIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS10cmlnZ2VyJztcbmltcG9ydCB7IE5iUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuLyoqXG4gKiBQb3dlcmZ1bCBwb3BvdmVyIGRpcmVjdGl2ZSwgd2hpY2ggcHJvdmlkZXMgdGhlIGJlc3QgVVggZm9yIHlvdXIgdXNlcnMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgcG9wb3Zlci9wb3BvdmVyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBQb3BvdmVyIGNhbiBhY2NlcHQgZGlmZmVyZW50IGNvbnRlbnQgc3VjaCBhczpcbiAqIFRlbXBsYXRlUmVmXG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBbbmJQb3BvdmVyXT1cInRlbXBsYXRlUmVmXCI+PC9idXR0b24+XG4gKiA8bmctdGVtcGxhdGUgI3RlbXBsYXRlUmVmPlxuICogICA8c3Bhbj5IZWxsbywgUG9wb3ZlciE8L3NwYW4+XG4gKiA8L25nLXRlbXBsYXRlPlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlBvcG92ZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iUG9wb3Zlck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQ3VzdG9tIGNvbXBvbmVudHNcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYlBvcG92ZXJdPVwiTXlQb3BvdmVyQ29tcG9uZW50XCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBCb3RoIGN1c3RvbSBjb21wb25lbnRzIGFuZCB0ZW1wbGF0ZVJlZiBwb3BvdmVycyBjYW4gcmVjZWl2ZSAqY29udGVudENvbnRleHQqIHByb3BlcnR5XG4gKiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjb250ZW50IHByb3BzLlxuICpcbiAqIFByaW1pdGl2ZSB0eXBlc1xuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJQb3BvdmVyPVwiSGVsbG8sIFBvcG92ZXIhXCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBQb3BvdmVyIGhhcyBkaWZmZXJlbnQgcGxhY2VtZW50cywgc3VjaCBhczogdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBzdGFydCBhbmQgZW5kXG4gKiB3aGljaCBjYW4gYmUgdXNlZCBhcyBmb2xsb3dpbmc6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShQbGFjZW1lbnRzLCBwb3BvdmVyL3BvcG92ZXItcGxhY2VtZW50cy5jb21wb25lbnQpXG4gKlxuICogQnkgZGVmYXVsdCBwb3BvdmVyIHdpbGwgdHJ5IHRvIGFkanVzdCBpdHNlbGYgdG8gbWF4aW1hbGx5IGZpdCB2aWV3cG9ydFxuICogYW5kIHByb3ZpZGUgdGhlIGJlc3QgdXNlciBleHBlcmllbmNlLiBJdCB3aWxsIHRyeSB0byBjaGFuZ2UgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgY29udGFpbmVyLlxuICogSWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW91ciBzZXQgaXQgYG5vb3BgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJQb3BvdmVyPVwiSGVsbG8sIFBvcG92ZXIhXCIgbmJQb3BvdmVyQWRqdXN0bWVudD1cIm5vb3BcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIFBvcG92ZXIgaGFzIGEgbnVtYmVyIG9mIHRyaWdnZXJzIHdoaWNoIHByb3ZpZGVzIGFuIGFiaWxpdHkgdG8gc2hvdyBhbmQgaGlkZSB0aGUgY29tcG9uZW50IGluIGRpZmZlcmVudCB3YXlzOlxuICpcbiAqIC0gQ2xpY2sgbW9kZSBzaG93cyB0aGUgY29tcG9uZW50IHdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCBoaWRlcyB3aGVuIHRoZSB1c2VyIGNsaWNrc1xuICogc29tZXdoZXJlIG9uIHRoZSBkb2N1bWVudCBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gKiAtIEhpbnQgcHJvdmlkZXMgY2FwYWJpbGl0eSB0byBzaG93IHRoZSBjb21wb25lbnQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50XG4gKiBhbmQgaGlkZSB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdXQgb2YgdGhlIGhvc3QuXG4gKiAtIEhvdmVyIHdvcmtzIGxpa2UgaGludCBtb2RlIHdpdGggb25lIGV4Y2VwdGlvbiAtIHdoZW4gdGhlIHVzZXIgbW92ZXMgbW91c2UgZnJvbSBob3N0IGVsZW1lbnQgdG9cbiAqIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGUgY29tcG9uZW50IHJlbWFpbnMgb3Blbiwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBpbnRlcmFjdCB3aXRoIGl0IGNvbnRlbnQuXG4gKiAtIEZvY3VzIG1vZGUgaXMgYXBwbGllZCB3aGVuIHVzZXIgZm9jdXNlcyB0aGUgZWxlbWVudC5cbiAqIC0gTm9vcCBtb2RlIC0gdGhlIGNvbXBvbmVudCB3b24ndCByZWFjdCB0byB0aGUgdXNlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF2YWlsYWJsZSBUcmlnZ2VycywgcG9wb3Zlci9wb3BvdmVyLW1vZGVzLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIE5vb3AgbW9kZSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGNvbnRyb2wgUG9wb3ZlciBwcm9ncmFtbWF0aWNhbGx5LCBmb3IgZXhhbXBsZSBzaG93L2hpZGVcbiAqIGFzIGEgcmVzdWx0IG9mIHNvbWUgdGhpcmQtcGFydHkgYWN0aW9uLCBsaWtlIEhUVFAgcmVxdWVzdCBvciB2YWxpZGF0aW9uIGNoZWNrOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTWFudWFsIENvbnRyb2wsIHBvcG92ZXIvcG9wb3Zlci1ub29wLmNvbXBvbmVudClcbiAqXG4gKiBCZWxvdyBhcmUgZXhhbXBsZXMgZm9yIG1hbnVhbCBwb3BvdmVyIHNldHRpbmdzIGNvbnRyb2wsIGJvdGggdmlhIHRlbXBsYXRlIGJpbmRpbmcgYW5kIGNvZGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBvcG92ZXIgU2V0dGluZ3MsIHBvcG92ZXIvcG9wb3Zlci1keW5hbWljLmNvbXBvbmVudClcbiAqXG4gKiBQbGVhc2Ugbm90ZSwgd2hpbGUgbWFuaXB1bGF0aW5nIFBvcG92ZXIgc2V0dGluZyB2aWEgY29kZSwgeW91IG5lZWQgdG8gY2FsbCBgcmVidWlsZCgpYCBtZXRob2QgdG8gYXBwbHkgdGhlIHNldHRpbmdzXG4gKiBjaGFuZ2VkLlxuICogQHN0YWNrZWQtZXhhbXBsZShQb3BvdmVyIFNldHRpbmdzIENvZGUsIHBvcG92ZXIvcG9wb3Zlci1keW5hbWljLWNvZGUuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoVGVtcGxhdGUgUmVmLCBwb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUtcmVmLmNvbXBvbmVudClcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoQ3VzdG9tIENvbXBvbmVudCwgcG9wb3Zlci9wb3BvdmVyLWN1c3RvbS1jb21wb25lbnQuY29tcG9uZW50KVxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iUG9wb3ZlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE5iRHluYW1pY092ZXJsYXlDb250cm9sbGVyLCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgICBwcm90ZWN0ZWQgaG9zdFJlZjogRWxlbWVudFJlZjtcbiAgICBwcm90ZWN0ZWQgZHluYW1pY092ZXJsYXlIYW5kbGVyOiBOYkR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbiAgICBwcm90ZWN0ZWQgcG9wb3ZlckNvbXBvbmVudDogdHlwZW9mIE5iUG9wb3ZlckNvbXBvbmVudDtcbiAgICBwcm90ZWN0ZWQgZHluYW1pY092ZXJsYXk6IE5iRHluYW1pY092ZXJsYXk7XG4gICAgcHJvdGVjdGVkIGRlc3Ryb3kkOiBTdWJqZWN0PHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIFBvcG92ZXIgY29udGVudCB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGluIE5iQXJyb3dlZE92ZXJsYXlDb250YWluZXJDb21wb25lbnQuXG4gICAgICogQXZhaWxhYmxlIGNvbnRlbnQ6IHRlbXBsYXRlIHJlZiwgY29tcG9uZW50IGFuZCBhbnkgcHJpbWl0aXZlLlxuICAgICAqICovXG4gICAgY29udGVudDogTmJPdmVybGF5Q29udGVudDtcbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgY29udGVudCBjb250ZXh0LiBXaWxsIGJlIGFwcGxpZWQgdG8gdGhlIHJlbmRlcmVkIGNvbXBvbmVudC5cbiAgICAgKiAqL1xuICAgIGNvbnRleHQ6IE9iamVjdDtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgcmVsYXRpdmVseSBob3N0IGVsZW1lbnQgYmFzZWQgb24gdGhlIHBvc2l0aW9uLlxuICAgICAqIENhbiBiZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0IG9yIGVuZC5cbiAgICAgKiAqL1xuICAgIHBvc2l0aW9uOiBOYlBvc2l0aW9uO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9wb3NpdGlvbjogTmJQb3NpdGlvblZhbHVlcztcbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgcG9zaXRpb24gd2lsbCBiZSBjaGFuZ2VzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhpcyBzdHJhdGVneSBpZiBjb250YWluZXIgY2FuJ3QgZml0IHZpZXcgcG9ydC5cbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbm9vcGAgdmFsdWUgaWYgeW91IHdhbnQgdG8gZGlzYWJsZSBhdXRvbWF0aWNhbGx5IGFkanVzdG1lbnQuXG4gICAgICogQXZhaWxhYmxlIHZhbHVlczogYGNsb2Nrd2lzZWAgKGRlZmF1bHQpLCBgY291bnRlcmNsb2Nrd2lzZWAsIGB2ZXJ0aWNhbGAsIGBob3Jpem9udGFsYCwgYG5vb3BgLlxuICAgICAqICovXG4gICAgZ2V0IGFkanVzdG1lbnQoKTogTmJBZGp1c3RtZW50O1xuICAgIHNldCBhZGp1c3RtZW50KHZhbHVlOiBOYkFkanVzdG1lbnQpO1xuICAgIHByb3RlY3RlZCBfYWRqdXN0bWVudDogTmJBZGp1c3RtZW50O1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB3aGVuIHRoZSBjb250YWluZXIgd2lsbCBiZSBzaG93bi5cbiAgICAgKiBBdmFpbGFibGUgb3B0aW9uczogYGNsaWNrYCwgYGhvdmVyYCwgYGhpbnRgLCBgZm9jdXNgIGFuZCBgbm9vcGBcbiAgICAgKiAqL1xuICAgIHRyaWdnZXI6IE5iVHJpZ2dlcjtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfdHJpZ2dlcjogTmJUcmlnZ2VyVmFsdWVzO1xuICAgIC8qKlxuICAgICAqIFNldHMgcG9wb3ZlciBvZmZzZXRcbiAgICAgKiAqL1xuICAgIG9mZnNldDogbnVtYmVyO1xuICAgIHBvcG92ZXJDbGFzczogc3RyaW5nO1xuICAgIG5iUG9wb3ZlclNob3dTdGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPHtcbiAgICAgICAgaXNTaG93bjogYm9vbGVhbjtcbiAgICB9PjtcbiAgICBnZXQgaXNTaG93bigpOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWY6IEVsZW1lbnRSZWYsIGR5bmFtaWNPdmVybGF5SGFuZGxlcjogTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZDtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICByZWJ1aWxkKCk6IHZvaWQ7XG4gICAgc2hvdygpOiB2b2lkO1xuICAgIGhpZGUoKTogdm9pZDtcbiAgICB0b2dnbGUoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBjb25maWd1cmVEeW5hbWljT3ZlcmxheSgpOiBOYkR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbn1cbiJdfQ==