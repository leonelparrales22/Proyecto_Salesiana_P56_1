/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { AfterViewInit, ComponentRef, ElementRef, OnChanges, OnDestroy, OnInit } from '@angular/core';
import { Subject } from 'rxjs';
import { NbDynamicOverlayController } from '../cdk/overlay/dynamic/dynamic-overlay';
import { NbDynamicOverlayHandler } from '../cdk/overlay/dynamic/dynamic-overlay-handler';
import { NbOverlayRef } from '../cdk/overlay/mapping';
import { NbAdjustableConnectedPositionStrategy, NbAdjustment, NbPosition } from '../cdk/overlay/overlay-position';
import { NbTrigger, NbTriggerValues } from '../cdk/overlay/overlay-trigger';
import { NbMenuItem, NbMenuService } from '../menu/menu.service';
/**
 * Full featured context menu directive.
 *
 * @stacked-example(Showcase, context-menu/context-menu-showcase.component)
 *
 * Just pass menu items array:
 *
 * ```html
 * <button [nbContextMenu]="items"></button>
 * ...
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 * ### Installation
 *
 * Import `NbContextMenuModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbContextMenuModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * Also make sure `NbMenuModule` is imported to your `app.module`.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * If you want to handle context menu clicks you have to pass `nbContextMenuTag`
 * param and register to events using NbMenuService.
 * `NbContextMenu` renders plain `NbMenu` inside, so
 * you have to work with it just like with `NbMenu` component:
 *
 * @stacked-example(Menu item click, context-menu/context-menu-click.component)
 *
 * Context menu has different placements, such as: top, bottom, left and right
 * which can be used as following:
 *
 * ```html
 * <button [nbContextMenu]="items" nbContextMenuPlacement="right"></button>
 * ```
 *
 * ```ts
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 *
 * By default context menu will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the context menu.
 * If you wanna disable this behaviour just set it falsy value.
 *
 * ```html
 * <button [nbContextMenu]="items" nbContextMenuAdjustment="counterclockwise"></button>
 * ```
 *
 * ```ts
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 * Context menu has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, context-menu/context-menu-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, context-menu/context-menu-noop.component)
 *
 * @stacked-example(Manual Control, context-menu/context-menu-right-click.component)
 * */
import * as ɵngcc0 from '@angular/core';
export declare class NbContextMenuDirective implements NbDynamicOverlayController, OnChanges, AfterViewInit, OnDestroy, OnInit {
    private hostRef;
    private menuService;
    private dynamicOverlayHandler;
    contextMenuHost: boolean;
    /**
     * Position will be calculated relatively host element based on the position.
     * Can be top, right, bottom and left.
     * */
    position: NbPosition;
    /**
     * Container position will be changes automatically based on this strategy if container can't fit view port.
     * Set this property to any falsy value if you want to disable automatically adjustment.
     * Available values: clockwise, counterclockwise.
     * */
    adjustment: NbAdjustment;
    /**
     * Set NbMenu tag, which helps identify menu when working with NbMenuService.
     * */
    tag: string;
    /**
     * Basic menu items, will be passed to the internal NbMenuComponent.
     * */
    set items(items: NbMenuItem[]);
    /**
     * Describes when the container will be shown.
     * Available options: `click`, `hover`, `hint`, `focus` and `noop`
     * */
    trigger: NbTrigger;
    static ngAcceptInputType_trigger: NbTriggerValues;
    contextMenuClass: string;
    protected ref: NbOverlayRef;
    protected container: ComponentRef<any>;
    protected positionStrategy: NbAdjustableConnectedPositionStrategy;
    protected destroy$: Subject<void>;
    private _items;
    private dynamicOverlay;
    constructor(hostRef: ElementRef, menuService: NbMenuService, dynamicOverlayHandler: NbDynamicOverlayHandler);
    ngOnInit(): void;
    ngOnChanges(): void;
    ngAfterViewInit(): void;
    rebuild(): void;
    show(): void;
    hide(): void;
    toggle(): void;
    ngOnDestroy(): void;
    protected configureDynamicOverlay(): NbDynamicOverlayHandler;
    private validateItems;
    private subscribeOnItemClick;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbContextMenuDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbContextMenuDirective, "[nbContextMenu]", never, {
    "position": "nbContextMenuPlacement";
    "adjustment": "nbContextMenuAdjustment";
    "trigger": "nbContextMenuTrigger";
    "contextMenuClass": "nbContextMenuClass";
    "items": "nbContextMenu";
    "tag": "nbContextMenuTag";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJjb250ZXh0LW1lbnUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnRSZWYsIEVsZW1lbnRSZWYsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5iRHluYW1pY092ZXJsYXlDb250cm9sbGVyIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvZHluYW1pYy9keW5hbWljLW92ZXJsYXknO1xuaW1wb3J0IHsgTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9keW5hbWljL2R5bmFtaWMtb3ZlcmxheS1oYW5kbGVyJztcbmltcG9ydCB7IE5iT3ZlcmxheVJlZiB9IGZyb20gJy4uL2Nkay9vdmVybGF5L21hcHBpbmcnO1xuaW1wb3J0IHsgTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSwgTmJBZGp1c3RtZW50LCBOYlBvc2l0aW9uIH0gZnJvbSAnLi4vY2RrL292ZXJsYXkvb3ZlcmxheS1wb3NpdGlvbic7XG5pbXBvcnQgeyBOYlRyaWdnZXIsIE5iVHJpZ2dlclZhbHVlcyB9IGZyb20gJy4uL2Nkay9vdmVybGF5L292ZXJsYXktdHJpZ2dlcic7XG5pbXBvcnQgeyBOYk1lbnVJdGVtLCBOYk1lbnVTZXJ2aWNlIH0gZnJvbSAnLi4vbWVudS9tZW51LnNlcnZpY2UnO1xuLyoqXG4gKiBGdWxsIGZlYXR1cmVkIGNvbnRleHQgbWVudSBkaXJlY3RpdmUuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgY29udGV4dC1tZW51L2NvbnRleHQtbWVudS1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogSnVzdCBwYXNzIG1lbnUgaXRlbXMgYXJyYXk6XG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBbbmJDb250ZXh0TWVudV09XCJpdGVtc1wiPjwvYnV0dG9uPlxuICogLi4uXG4gKiBpdGVtcyA9IFt7IHRpdGxlOiAnUHJvZmlsZScgfSwgeyB0aXRsZTogJ0xvZyBvdXQnIH1dO1xuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNvbnRleHRNZW51TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkNvbnRleHRNZW51TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiBBbHNvIG1ha2Ugc3VyZSBgTmJNZW51TW9kdWxlYCBpcyBpbXBvcnRlZCB0byB5b3VyIGBhcHAubW9kdWxlYC5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJNZW51TW9kdWxlLmZvclJvb3QoKSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGNvbnRleHQgbWVudSBjbGlja3MgeW91IGhhdmUgdG8gcGFzcyBgbmJDb250ZXh0TWVudVRhZ2BcbiAqIHBhcmFtIGFuZCByZWdpc3RlciB0byBldmVudHMgdXNpbmcgTmJNZW51U2VydmljZS5cbiAqIGBOYkNvbnRleHRNZW51YCByZW5kZXJzIHBsYWluIGBOYk1lbnVgIGluc2lkZSwgc29cbiAqIHlvdSBoYXZlIHRvIHdvcmsgd2l0aCBpdCBqdXN0IGxpa2Ugd2l0aCBgTmJNZW51YCBjb21wb25lbnQ6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShNZW51IGl0ZW0gY2xpY2ssIGNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtY2xpY2suY29tcG9uZW50KVxuICpcbiAqIENvbnRleHQgbWVudSBoYXMgZGlmZmVyZW50IHBsYWNlbWVudHMsIHN1Y2ggYXM6IHRvcCwgYm90dG9tLCBsZWZ0IGFuZCByaWdodFxuICogd2hpY2ggY2FuIGJlIHVzZWQgYXMgZm9sbG93aW5nOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gW25iQ29udGV4dE1lbnVdPVwiaXRlbXNcIiBuYkNvbnRleHRNZW51UGxhY2VtZW50PVwicmlnaHRcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKiBpdGVtcyA9IFt7IHRpdGxlOiAnUHJvZmlsZScgfSwgeyB0aXRsZTogJ0xvZyBvdXQnIH1dO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCBjb250ZXh0IG1lbnUgd2lsbCB0cnkgdG8gYWRqdXN0IGl0c2VsZiB0byBtYXhpbWFsbHkgZml0IHZpZXdwb3J0XG4gKiBhbmQgcHJvdmlkZSB0aGUgYmVzdCB1c2VyIGV4cGVyaWVuY2UuIEl0IHdpbGwgdHJ5IHRvIGNoYW5nZSBwb3NpdGlvbiBvZiB0aGUgY29udGV4dCBtZW51LlxuICogSWYgeW91IHdhbm5hIGRpc2FibGUgdGhpcyBiZWhhdmlvdXIganVzdCBzZXQgaXQgZmFsc3kgdmFsdWUuXG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBbbmJDb250ZXh0TWVudV09XCJpdGVtc1wiIG5iQ29udGV4dE1lbnVBZGp1c3RtZW50PVwiY291bnRlcmNsb2Nrd2lzZVwiPjwvYnV0dG9uPlxuICogYGBgXG4gKlxuICogYGBgdHNcbiAqIGl0ZW1zID0gW3sgdGl0bGU6ICdQcm9maWxlJyB9LCB7IHRpdGxlOiAnTG9nIG91dCcgfV07XG4gKiBgYGBcbiAqIENvbnRleHQgbWVudSBoYXMgYSBudW1iZXIgb2YgdHJpZ2dlcnMgd2hpY2ggcHJvdmlkZXMgYW4gYWJpbGl0eSB0byBzaG93IGFuZCBoaWRlIHRoZSBjb21wb25lbnQgaW4gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBDbGljayBtb2RlIHNob3dzIHRoZSBjb21wb25lbnQgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBob3N0IGVsZW1lbnQgYW5kIGhpZGVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzXG4gKiBzb21ld2hlcmUgb24gdGhlIGRvY3VtZW50IG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAqIC0gSGludCBwcm92aWRlcyBjYXBhYmlsaXR5IHRvIHNob3cgdGhlIGNvbXBvbmVudCB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoZSBob3N0IGVsZW1lbnRcbiAqIGFuZCBoaWRlIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG91dCBvZiB0aGUgaG9zdC5cbiAqIC0gSG92ZXIgd29ya3MgbGlrZSBoaW50IG1vZGUgd2l0aCBvbmUgZXhjZXB0aW9uIC0gd2hlbiB0aGUgdXNlciBtb3ZlcyBtb3VzZSBmcm9tIGhvc3QgZWxlbWVudCB0b1xuICogdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoZSBjb21wb25lbnQgcmVtYWlucyBvcGVuLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGludGVyYWN0IHdpdGggaXQgY29udGVudC5cbiAqIC0gRm9jdXMgbW9kZSBpcyBhcHBsaWVkIHdoZW4gdXNlciBmb2N1c2VzIHRoZSBlbGVtZW50LlxuICogLSBOb29wIG1vZGUgLSB0aGUgY29tcG9uZW50IHdvbid0IHJlYWN0IHRvIHRoZSB1c2VyIGludGVyYWN0aW9uLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQXZhaWxhYmxlIFRyaWdnZXJzLCBjb250ZXh0LW1lbnUvY29udGV4dC1tZW51LW1vZGVzLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIE5vb3AgbW9kZSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGNvbnRyb2wgUG9wb3ZlciBwcm9ncmFtbWF0aWNhbGx5LCBmb3IgZXhhbXBsZSBzaG93L2hpZGVcbiAqIGFzIGEgcmVzdWx0IG9mIHNvbWUgdGhpcmQtcGFydHkgYWN0aW9uLCBsaWtlIEhUVFAgcmVxdWVzdCBvciB2YWxpZGF0aW9uIGNoZWNrOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTWFudWFsIENvbnRyb2wsIGNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtbm9vcC5jb21wb25lbnQpXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShNYW51YWwgQ29udHJvbCwgY29udGV4dC1tZW51L2NvbnRleHQtbWVudS1yaWdodC1jbGljay5jb21wb25lbnQpXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJDb250ZXh0TWVudURpcmVjdGl2ZSBpbXBsZW1lbnRzIE5iRHluYW1pY092ZXJsYXlDb250cm9sbGVyLCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgICBwcml2YXRlIGhvc3RSZWY7XG4gICAgcHJpdmF0ZSBtZW51U2VydmljZTtcbiAgICBwcml2YXRlIGR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbiAgICBjb250ZXh0TWVudUhvc3Q6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gd2lsbCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwb3NpdGlvbi5cbiAgICAgKiBDYW4gYmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0LlxuICAgICAqICovXG4gICAgcG9zaXRpb246IE5iUG9zaXRpb247XG4gICAgLyoqXG4gICAgICogQ29udGFpbmVyIHBvc2l0aW9uIHdpbGwgYmUgY2hhbmdlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoaXMgc3RyYXRlZ3kgaWYgY29udGFpbmVyIGNhbid0IGZpdCB2aWV3IHBvcnQuXG4gICAgICogU2V0IHRoaXMgcHJvcGVydHkgdG8gYW55IGZhbHN5IHZhbHVlIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgYXV0b21hdGljYWxseSBhZGp1c3RtZW50LlxuICAgICAqIEF2YWlsYWJsZSB2YWx1ZXM6IGNsb2Nrd2lzZSwgY291bnRlcmNsb2Nrd2lzZS5cbiAgICAgKiAqL1xuICAgIGFkanVzdG1lbnQ6IE5iQWRqdXN0bWVudDtcbiAgICAvKipcbiAgICAgKiBTZXQgTmJNZW51IHRhZywgd2hpY2ggaGVscHMgaWRlbnRpZnkgbWVudSB3aGVuIHdvcmtpbmcgd2l0aCBOYk1lbnVTZXJ2aWNlLlxuICAgICAqICovXG4gICAgdGFnOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQmFzaWMgbWVudSBpdGVtcywgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGludGVybmFsIE5iTWVudUNvbXBvbmVudC5cbiAgICAgKiAqL1xuICAgIHNldCBpdGVtcyhpdGVtczogTmJNZW51SXRlbVtdKTtcbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgd2hlbiB0aGUgY29udGFpbmVyIHdpbGwgYmUgc2hvd24uXG4gICAgICogQXZhaWxhYmxlIG9wdGlvbnM6IGBjbGlja2AsIGBob3ZlcmAsIGBoaW50YCwgYGZvY3VzYCBhbmQgYG5vb3BgXG4gICAgICogKi9cbiAgICB0cmlnZ2VyOiBOYlRyaWdnZXI7XG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3RyaWdnZXI6IE5iVHJpZ2dlclZhbHVlcztcbiAgICBjb250ZXh0TWVudUNsYXNzOiBzdHJpbmc7XG4gICAgcHJvdGVjdGVkIHJlZjogTmJPdmVybGF5UmVmO1xuICAgIHByb3RlY3RlZCBjb250YWluZXI6IENvbXBvbmVudFJlZjxhbnk+O1xuICAgIHByb3RlY3RlZCBwb3NpdGlvblN0cmF0ZWd5OiBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuICAgIHByb3RlY3RlZCBkZXN0cm95JDogU3ViamVjdDx2b2lkPjtcbiAgICBwcml2YXRlIF9pdGVtcztcbiAgICBwcml2YXRlIGR5bmFtaWNPdmVybGF5O1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWY6IEVsZW1lbnRSZWYsIG1lbnVTZXJ2aWNlOiBOYk1lbnVTZXJ2aWNlLCBkeW5hbWljT3ZlcmxheUhhbmRsZXI6IE5iRHluYW1pY092ZXJsYXlIYW5kbGVyKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgcmVidWlsZCgpOiB2b2lkO1xuICAgIHNob3coKTogdm9pZDtcbiAgICBoaWRlKCk6IHZvaWQ7XG4gICAgdG9nZ2xlKCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgY29uZmlndXJlRHluYW1pY092ZXJsYXkoKTogTmJEeW5hbWljT3ZlcmxheUhhbmRsZXI7XG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUl0ZW1zO1xuICAgIHByaXZhdGUgc3Vic2NyaWJlT25JdGVtQ2xpY2s7XG59XG4iXX0=