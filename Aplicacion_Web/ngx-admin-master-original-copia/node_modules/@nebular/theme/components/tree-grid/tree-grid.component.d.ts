import { AfterViewInit, ChangeDetectorRef, ElementRef, IterableDiffers, OnDestroy } from '@angular/core';
import { NbPlatform } from '../cdk/platform/platform-service';
import { NbDirectionality } from '../cdk/bidi/bidi-service';
import { NbTable } from '../cdk/table/table.module';
import { NbTreeGridDataSource, NbTreeGridDataSourceBuilder } from './data-source/tree-grid-data-source';
import { NbTreeGridPresentationNode } from './data-source/tree-grid.model';
import { NbToggleOptions } from './data-source/tree-grid.service';
import { NbTreeGridRowComponent } from './tree-grid-row.component';
import { NbTreeGridCellDirective } from './tree-grid-cell.component';
import { NbBooleanInput } from '../helpers';
/**
 * Tree grid component that can be used to display nested rows of data.
 * Supports filtering and sorting.
 * @stacked-example(Showcase, tree-grid/tree-grid-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTreeGridModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTreeGridModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * As the most basic usage you need to define [nbTreeGridRowDef](docs/components/treegrid/api#nbtreegridrowdefdirective)
 * where you should pass columns to display in rows and
 * [nbTreeGridColumnDef](docs/components/treegrid/api#nbtreegridcolumndefdirective) - component containing cell
 * definitions for each column passed to row definition.
 * @stacked-example(Basic, tree-grid/tree-grid-basic.component)
 *
 * `NbTreeGridComponent`'s source input and `NbTreeGridDataSourceBuilder.create` expecting data to be an array of
 * objects with `data`, `children` and `expanded` properties. If your data doesn't match this interface, you can pass
 * getter functions for each property as arguments to `NbTreeGridDataSourceBuilder.create` method.
 * @stacked-example(Custom node structure, tree-grid/tree-grid-custom-node-structure.component)
 *
 * To use sorting you can add `nbSort` directive to table and subscribe to `sort` method. When user click on header,
 * sort event will be emitted. Event object contain clicked column name and desired sort direction.
 * @stacked-example(Sortable, tree-grid/tree-grid-sortable.component)
 *
 * You can use `Data Source Builder` to create `NbTreeGridDataSource` which would have toggle, sort and
 * filter methods. Then you can call this methods to change sort or toggle rows programmatically. Also `nbSort` and
 * `nbFilterInput` directives both support `NbTreeGridDataSource`, so you can pass it directly as an input and
 * directives will trigger sort, toggle themselves.
 * @stacked-example(Data Source Builder, tree-grid/tree-grid-showcase.component)
 *
 * You can create responsive grid by setting `hideOn` and `showOn` inputs of
 * [nbTreeGridColumnDef](docs/components/tree-grid/api#nbtreegridcolumndefdirective) directive.
 * When viewport reaches specified width grid hides or shows columns.
 * @stacked-example(Responsive columns, tree-grid/tree-grid-responsive.component)
 *
 * To customize sort or row toggle icons you can use `nbSortHeaderIcon` and `nbTreeGridRowToggle` directives
 * respectively. `nbSortHeaderIcon` is a structural directive and it's implicit context set to current direction.
 * Also context has three properties: `isAscending`, `isDescending` and `isNone`.
 * @stacked-example(Custom icons, tree-grid/tree-grid-custom-icons.component)
 *
 * By default, row to toggle happens when user clicks anywhere in the row. Also double click expands row deeply.
 * To disable this you can set `[clickToToggle]="false"` input of `nbTreeGridRow`.
 * @stacked-example(Disable click toggle, tree-grid/tree-grid-disable-click-toggle.component)
 *
 * @styles
 *
 * tree-grid-cell-border-width:
 * tree-grid-cell-border-style:
 * tree-grid-cell-border-color:
 * tree-grid-row-min-height:
 * tree-grid-cell-padding:
 * tree-grid-header-background-color:
 * tree-grid-header-text-color:
 * tree-grid-header-text-font-family:
 * tree-grid-header-text-font-size:
 * tree-grid-header-text-font-weight:
 * tree-grid-header-text-line-height:
 * tree-grid-footer-background-color:
 * tree-grid-footer-text-color:
 * tree-grid-footer-text-font-family:
 * tree-grid-footer-text-font-size:
 * tree-grid-footer-text-font-weight:
 * tree-grid-footer-text-line-height:
 * tree-grid-row-background-color:
 * tree-grid-row-even-background-color:
 * tree-grid-row-hover-background-color:
 * tree-grid-row-text-color:
 * tree-grid-row-text-font-family:
 * tree-grid-row-text-font-size:
 * tree-grid-row-text-font-weight:
 * tree-grid-row-text-line-height:
 * tree-grid-sort-header-button-background-color:
 * tree-grid-sort-header-button-border:
 * tree-grid-sort-header-button-padding:
 */
import * as ɵngcc0 from '@angular/core';
export declare class NbTreeGridComponent<T> extends NbTable<NbTreeGridPresentationNode<T>> implements AfterViewInit, OnDestroy {
    private dataSourceBuilder;
    private window;
    constructor(dataSourceBuilder: NbTreeGridDataSourceBuilder<T>, differs: IterableDiffers, changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef, role: string, dir: NbDirectionality, document: any, platform: NbPlatform, window: any);
    private destroy$;
    private _source;
    private platform;
    /**
     * The table's data
     * @param data
     * @type {<T>[] | NbTreeGridDataSource}
     */
    set source(data: T[] | NbTreeGridDataSource<T>);
    levelPadding: string;
    /**
     * Make all columns equal width. False by default.
     */
    set equalColumnsWidth(value: boolean);
    get equalColumnsWidth(): boolean;
    private equalColumnsWidthValue;
    static ngAcceptInputType_equalColumnsWidth: NbBooleanInput;
    readonly treeClass = true;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    toggleRow(row: NbTreeGridRowComponent, options?: NbToggleOptions): void;
    toggleCellRow(cell: NbTreeGridCellDirective): void;
    getColumnWidth(): string;
    getCellLevel(cell: NbTreeGridCellDirective, columnName: string): number;
    private getRowContext;
    private getCellContext;
    private getContextByCellEl;
    private getContextByRowEl;
    private getColumns;
    private getColumnsCount;
    private isFirstColumn;
    private checkDefsCount;
    private updateVisibleColumns;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbTreeGridComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbTreeGridComponent<any>, "table[nbTreeGrid]", never, {
    "levelPadding": "levelPadding";
    "source": "nbTreeGrid";
    "equalColumnsWidth": "equalColumnsWidth";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJ0cmVlLWdyaWQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgSXRlcmFibGVEaWZmZXJzLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5iUGxhdGZvcm0gfSBmcm9tICcuLi9jZGsvcGxhdGZvcm0vcGxhdGZvcm0tc2VydmljZSc7XG5pbXBvcnQgeyBOYkRpcmVjdGlvbmFsaXR5IH0gZnJvbSAnLi4vY2RrL2JpZGkvYmlkaS1zZXJ2aWNlJztcbmltcG9ydCB7IE5iVGFibGUgfSBmcm9tICcuLi9jZGsvdGFibGUvdGFibGUubW9kdWxlJztcbmltcG9ydCB7IE5iVHJlZUdyaWREYXRhU291cmNlLCBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIgfSBmcm9tICcuL2RhdGEtc291cmNlL3RyZWUtZ3JpZC1kYXRhLXNvdXJjZSc7XG5pbXBvcnQgeyBOYlRyZWVHcmlkUHJlc2VudGF0aW9uTm9kZSB9IGZyb20gJy4vZGF0YS1zb3VyY2UvdHJlZS1ncmlkLm1vZGVsJztcbmltcG9ydCB7IE5iVG9nZ2xlT3B0aW9ucyB9IGZyb20gJy4vZGF0YS1zb3VyY2UvdHJlZS1ncmlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJUcmVlR3JpZFJvd0NvbXBvbmVudCB9IGZyb20gJy4vdHJlZS1ncmlkLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUgfSBmcm9tICcuL3RyZWUtZ3JpZC1jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYkJvb2xlYW5JbnB1dCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuLyoqXG4gKiBUcmVlIGdyaWQgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBuZXN0ZWQgcm93cyBvZiBkYXRhLlxuICogU3VwcG9ydHMgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgdHJlZS1ncmlkL3RyZWUtZ3JpZC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJUcmVlR3JpZE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUcmVlR3JpZE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIEFzIHRoZSBtb3N0IGJhc2ljIHVzYWdlIHlvdSBuZWVkIHRvIGRlZmluZSBbbmJUcmVlR3JpZFJvd0RlZl0oZG9jcy9jb21wb25lbnRzL3RyZWVncmlkL2FwaSNuYnRyZWVncmlkcm93ZGVmZGlyZWN0aXZlKVxuICogd2hlcmUgeW91IHNob3VsZCBwYXNzIGNvbHVtbnMgdG8gZGlzcGxheSBpbiByb3dzIGFuZFxuICogW25iVHJlZUdyaWRDb2x1bW5EZWZdKGRvY3MvY29tcG9uZW50cy90cmVlZ3JpZC9hcGkjbmJ0cmVlZ3JpZGNvbHVtbmRlZmRpcmVjdGl2ZSkgLSBjb21wb25lbnQgY29udGFpbmluZyBjZWxsXG4gKiBkZWZpbml0aW9ucyBmb3IgZWFjaCBjb2x1bW4gcGFzc2VkIHRvIHJvdyBkZWZpbml0aW9uLlxuICogQHN0YWNrZWQtZXhhbXBsZShCYXNpYywgdHJlZS1ncmlkL3RyZWUtZ3JpZC1iYXNpYy5jb21wb25lbnQpXG4gKlxuICogYE5iVHJlZUdyaWRDb21wb25lbnRgJ3Mgc291cmNlIGlucHV0IGFuZCBgTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyLmNyZWF0ZWAgZXhwZWN0aW5nIGRhdGEgdG8gYmUgYW4gYXJyYXkgb2ZcbiAqIG9iamVjdHMgd2l0aCBgZGF0YWAsIGBjaGlsZHJlbmAgYW5kIGBleHBhbmRlZGAgcHJvcGVydGllcy4gSWYgeW91ciBkYXRhIGRvZXNuJ3QgbWF0Y2ggdGhpcyBpbnRlcmZhY2UsIHlvdSBjYW4gcGFzc1xuICogZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgZWFjaCBwcm9wZXJ0eSBhcyBhcmd1bWVudHMgdG8gYE5iVHJlZUdyaWREYXRhU291cmNlQnVpbGRlci5jcmVhdGVgIG1ldGhvZC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQ3VzdG9tIG5vZGUgc3RydWN0dXJlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLWN1c3RvbS1ub2RlLXN0cnVjdHVyZS5jb21wb25lbnQpXG4gKlxuICogVG8gdXNlIHNvcnRpbmcgeW91IGNhbiBhZGQgYG5iU29ydGAgZGlyZWN0aXZlIHRvIHRhYmxlIGFuZCBzdWJzY3JpYmUgdG8gYHNvcnRgIG1ldGhvZC4gV2hlbiB1c2VyIGNsaWNrIG9uIGhlYWRlcixcbiAqIHNvcnQgZXZlbnQgd2lsbCBiZSBlbWl0dGVkLiBFdmVudCBvYmplY3QgY29udGFpbiBjbGlja2VkIGNvbHVtbiBuYW1lIGFuZCBkZXNpcmVkIHNvcnQgZGlyZWN0aW9uLlxuICogQHN0YWNrZWQtZXhhbXBsZShTb3J0YWJsZSwgdHJlZS1ncmlkL3RyZWUtZ3JpZC1zb3J0YWJsZS5jb21wb25lbnQpXG4gKlxuICogWW91IGNhbiB1c2UgYERhdGEgU291cmNlIEJ1aWxkZXJgIHRvIGNyZWF0ZSBgTmJUcmVlR3JpZERhdGFTb3VyY2VgIHdoaWNoIHdvdWxkIGhhdmUgdG9nZ2xlLCBzb3J0IGFuZFxuICogZmlsdGVyIG1ldGhvZHMuIFRoZW4geW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kcyB0byBjaGFuZ2Ugc29ydCBvciB0b2dnbGUgcm93cyBwcm9ncmFtbWF0aWNhbGx5LiBBbHNvIGBuYlNvcnRgIGFuZFxuICogYG5iRmlsdGVySW5wdXRgIGRpcmVjdGl2ZXMgYm90aCBzdXBwb3J0IGBOYlRyZWVHcmlkRGF0YVNvdXJjZWAsIHNvIHlvdSBjYW4gcGFzcyBpdCBkaXJlY3RseSBhcyBhbiBpbnB1dCBhbmRcbiAqIGRpcmVjdGl2ZXMgd2lsbCB0cmlnZ2VyIHNvcnQsIHRvZ2dsZSB0aGVtc2VsdmVzLlxuICogQHN0YWNrZWQtZXhhbXBsZShEYXRhIFNvdXJjZSBCdWlsZGVyLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBZb3UgY2FuIGNyZWF0ZSByZXNwb25zaXZlIGdyaWQgYnkgc2V0dGluZyBgaGlkZU9uYCBhbmQgYHNob3dPbmAgaW5wdXRzIG9mXG4gKiBbbmJUcmVlR3JpZENvbHVtbkRlZl0oZG9jcy9jb21wb25lbnRzL3RyZWUtZ3JpZC9hcGkjbmJ0cmVlZ3JpZGNvbHVtbmRlZmRpcmVjdGl2ZSkgZGlyZWN0aXZlLlxuICogV2hlbiB2aWV3cG9ydCByZWFjaGVzIHNwZWNpZmllZCB3aWR0aCBncmlkIGhpZGVzIG9yIHNob3dzIGNvbHVtbnMuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFJlc3BvbnNpdmUgY29sdW1ucywgdHJlZS1ncmlkL3RyZWUtZ3JpZC1yZXNwb25zaXZlLmNvbXBvbmVudClcbiAqXG4gKiBUbyBjdXN0b21pemUgc29ydCBvciByb3cgdG9nZ2xlIGljb25zIHlvdSBjYW4gdXNlIGBuYlNvcnRIZWFkZXJJY29uYCBhbmQgYG5iVHJlZUdyaWRSb3dUb2dnbGVgIGRpcmVjdGl2ZXNcbiAqIHJlc3BlY3RpdmVseS4gYG5iU29ydEhlYWRlckljb25gIGlzIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUgYW5kIGl0J3MgaW1wbGljaXQgY29udGV4dCBzZXQgdG8gY3VycmVudCBkaXJlY3Rpb24uXG4gKiBBbHNvIGNvbnRleHQgaGFzIHRocmVlIHByb3BlcnRpZXM6IGBpc0FzY2VuZGluZ2AsIGBpc0Rlc2NlbmRpbmdgIGFuZCBgaXNOb25lYC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQ3VzdG9tIGljb25zLCB0cmVlLWdyaWQvdHJlZS1ncmlkLWN1c3RvbS1pY29ucy5jb21wb25lbnQpXG4gKlxuICogQnkgZGVmYXVsdCwgcm93IHRvIHRvZ2dsZSBoYXBwZW5zIHdoZW4gdXNlciBjbGlja3MgYW55d2hlcmUgaW4gdGhlIHJvdy4gQWxzbyBkb3VibGUgY2xpY2sgZXhwYW5kcyByb3cgZGVlcGx5LlxuICogVG8gZGlzYWJsZSB0aGlzIHlvdSBjYW4gc2V0IGBbY2xpY2tUb1RvZ2dsZV09XCJmYWxzZVwiYCBpbnB1dCBvZiBgbmJUcmVlR3JpZFJvd2AuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGUgY2xpY2sgdG9nZ2xlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLWRpc2FibGUtY2xpY2stdG9nZ2xlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogdHJlZS1ncmlkLWNlbGwtYm9yZGVyLXdpZHRoOlxuICogdHJlZS1ncmlkLWNlbGwtYm9yZGVyLXN0eWxlOlxuICogdHJlZS1ncmlkLWNlbGwtYm9yZGVyLWNvbG9yOlxuICogdHJlZS1ncmlkLXJvdy1taW4taGVpZ2h0OlxuICogdHJlZS1ncmlkLWNlbGwtcGFkZGluZzpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtaGVhZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtaGVhZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtY29sb3I6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtZm9udC1zaXplOlxuICogdHJlZS1ncmlkLWZvb3Rlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdHJlZS1ncmlkLWZvb3Rlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdHJlZS1ncmlkLXJvdy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLXJvdy1ldmVuLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtZm9udC1mYW1pbHk6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtZm9udC1zaXplOlxuICogdHJlZS1ncmlkLXJvdy10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdHJlZS1ncmlkLXJvdy10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdHJlZS1ncmlkLXNvcnQtaGVhZGVyLWJ1dHRvbi1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLXNvcnQtaGVhZGVyLWJ1dHRvbi1ib3JkZXI6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLXBhZGRpbmc6XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iVHJlZUdyaWRDb21wb25lbnQ8VD4gZXh0ZW5kcyBOYlRhYmxlPE5iVHJlZUdyaWRQcmVzZW50YXRpb25Ob2RlPFQ+PiBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBkYXRhU291cmNlQnVpbGRlcjtcbiAgICBwcml2YXRlIHdpbmRvdztcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlQnVpbGRlcjogTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyPFQ+LCBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcm9sZTogc3RyaW5nLCBkaXI6IE5iRGlyZWN0aW9uYWxpdHksIGRvY3VtZW50OiBhbnksIHBsYXRmb3JtOiBOYlBsYXRmb3JtLCB3aW5kb3c6IGFueSk7XG4gICAgcHJpdmF0ZSBkZXN0cm95JDtcbiAgICBwcml2YXRlIF9zb3VyY2U7XG4gICAgcHJpdmF0ZSBwbGF0Zm9ybTtcbiAgICAvKipcbiAgICAgKiBUaGUgdGFibGUncyBkYXRhXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAdHlwZSB7PFQ+W10gfCBOYlRyZWVHcmlkRGF0YVNvdXJjZX1cbiAgICAgKi9cbiAgICBzZXQgc291cmNlKGRhdGE6IFRbXSB8IE5iVHJlZUdyaWREYXRhU291cmNlPFQ+KTtcbiAgICBsZXZlbFBhZGRpbmc6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBNYWtlIGFsbCBjb2x1bW5zIGVxdWFsIHdpZHRoLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHNldCBlcXVhbENvbHVtbnNXaWR0aCh2YWx1ZTogYm9vbGVhbik7XG4gICAgZ2V0IGVxdWFsQ29sdW1uc1dpZHRoKCk6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBlcXVhbENvbHVtbnNXaWR0aFZhbHVlO1xuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9lcXVhbENvbHVtbnNXaWR0aDogTmJCb29sZWFuSW5wdXQ7XG4gICAgcmVhZG9ubHkgdHJlZUNsYXNzID0gdHJ1ZTtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHRvZ2dsZVJvdyhyb3c6IE5iVHJlZUdyaWRSb3dDb21wb25lbnQsIG9wdGlvbnM/OiBOYlRvZ2dsZU9wdGlvbnMpOiB2b2lkO1xuICAgIHRvZ2dsZUNlbGxSb3coY2VsbDogTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUpOiB2b2lkO1xuICAgIGdldENvbHVtbldpZHRoKCk6IHN0cmluZztcbiAgICBnZXRDZWxsTGV2ZWwoY2VsbDogTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUsIGNvbHVtbk5hbWU6IHN0cmluZyk6IG51bWJlcjtcbiAgICBwcml2YXRlIGdldFJvd0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBnZXRDZWxsQ29udGV4dDtcbiAgICBwcml2YXRlIGdldENvbnRleHRCeUNlbGxFbDtcbiAgICBwcml2YXRlIGdldENvbnRleHRCeVJvd0VsO1xuICAgIHByaXZhdGUgZ2V0Q29sdW1ucztcbiAgICBwcml2YXRlIGdldENvbHVtbnNDb3VudDtcbiAgICBwcml2YXRlIGlzRmlyc3RDb2x1bW47XG4gICAgcHJpdmF0ZSBjaGVja0RlZnNDb3VudDtcbiAgICBwcml2YXRlIHVwZGF0ZVZpc2libGVDb2x1bW5zO1xufVxuIl19