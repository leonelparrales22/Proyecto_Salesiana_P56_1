import { ElementRef, InjectionToken, OnDestroy, ChangeDetectorRef, Type } from '@angular/core';
import { ControlValueAccessor, ValidationErrors, Validator, ValidatorFn } from '@angular/forms';
import { Observable, Subject } from 'rxjs';
import { NbDateService } from '../calendar-kit/services/date.service';
/**
 * The `NbDatepickerAdapter` instances provide way how to parse, format and validate
 * different date types.
 * */
import * as ɵngcc0 from '@angular/core';
export declare abstract class NbDatepickerAdapter<D> {
    /**
     * Picker component class.
     * */
    abstract picker: Type<any>;
    /**
     * Parse date string according to the format.
     * */
    abstract parse(value: string, format: string): D;
    /**
     * Format date according to the format.
     * */
    abstract format(value: D, format: string): string;
    /**
     * Validates date string according to the passed format.
     * */
    abstract isValid(value: string, format: string): boolean;
}
/**
 * Validators config that will be used by form control to perform proper validation.
 * */
export interface NbPickerValidatorConfig<D> {
    /**
     * Minimum date available in picker.
     * */
    min: D;
    /**
     * Maximum date available in picker.
     * */
    max: D;
    /**
     * Predicate that determines is value available for picking.
     * */
    filter: (D: any) => boolean;
}
/**
 * Datepicker is an control that can pick any values anyway.
 * It has to be bound to the datepicker directive through nbDatepicker input.
 * */
export declare abstract class NbDatepicker<T> {
    /**
     * HTML input element date format.
     * */
    abstract format: string;
    abstract get value(): T;
    abstract set value(value: T);
    abstract get valueChange(): Observable<T>;
    abstract get init(): Observable<void>;
    /**
     * Attaches datepicker to the native input element.
     * */
    abstract attach(hostRef: ElementRef): any;
    /**
     * Returns validator configuration based on the input properties.
     * */
    abstract getValidatorConfig(): NbPickerValidatorConfig<T>;
    abstract show(): any;
    abstract hide(): any;
    abstract shouldHide(): boolean;
    abstract get isShown(): boolean;
    abstract get blur(): Observable<void>;
}
export declare const NB_DATE_ADAPTER: InjectionToken<NbDatepickerAdapter<any>>;
export declare const NB_DATE_SERVICE_OPTIONS: InjectionToken<unknown>;
/**
 * The `NbDatepickerDirective` is form control that gives you ability to select dates and ranges. The datepicker
 * is shown when input receives a `focus` event.
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker></nb-datepicker>
 * ```
 *
 * @stacked-example(Showcase, datepicker/datepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbDatepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbDatepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use range selection, you have to use `NbRangepickerComponent` instead:
 *
 * ```html
 * <input [nbDatepicker]="rangepicker">
 * <nb-rangepicker #rangepicker></nb-rangepicker>
 * ```
 *
 * Both range and date pickers support all parameters as calendar, so, check `NbCalendarComponent` for additional
 * info.
 *
 * @stacked-example(Range showcase, datepicker/rangepicker-showcase.component)
 *
 * Datepicker is the form control so it can be bound with angular forms through ngModel and form controls.
 *
 * @stacked-example(Forms, datepicker/datepicker-forms.component)
 *
 * `NbDatepickerDirective` may be validated using `min` and `max` dates passed to the datepicker.
 * And `filter` predicate that receives date object and has to return a boolean value.
 *
 * @stacked-example(Validation, datepicker/datepicker-validation.component)
 *
 * The `NbDatepickerComponent` supports date formatting:
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker format="MM\dd\yyyy"></nb-datepicker>
 * ```
 *
 * ## Formatting Issue
 *
 * By default, datepicker uses angulars `LOCALE_ID` token for localization and `DatePipe` for dates formatting.
 * And native `Date.parse(...)` for dates parsing. But native `Date.parse` function doesn't support formats.
 * To provide custom formatting you have to use one of the following packages:
 *
 * - `@nebular/moment` - provides moment date adapter that uses moment for date objects. This means datepicker than
 * will operate only moment date objects. If you want to use it you have to install it: `npm i @nebular/moment`, and
 * import `NbMomentDateModule` from this package.
 *
 * - `@nebular/date-fns` - adapter for popular date-fns library. This way is preferred if you need only date formatting.
 * Because date-fns is treeshakable, tiny and operates native date objects. If you want to use it you have to
 * install it: `npm i @nebular/date-fns`, and import `NbDateFnsDateModule` from this package.
 *
 * ### NbDateFnsDateModule
 *
 * Format is required when using `NbDateFnsDateModule`. You can set it via `format` input on datepicker component:
 * ```html
 * <nb-datepicker format="dd.MM.yyyy"></nb-datepicker>
 * ```
 * Also format can be set globally with `NbDateFnsDateModule.forRoot({ format: 'dd.MM.yyyy' })` and
 * `NbDateFnsDateModule.forChild({ format: 'dd.MM.yyyy' })` methods.
 *
 * Please note to use some of the formatting tokens you also need to pass
 * `{ useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true }` to date-fns parse and format functions.
 * You can configure options passed this functions by setting `formatOptions` and
 * `parseOptions` of options object passed to `NbDateFnsDateModule.forRoot` and `NbDateFnsDateModule.forChild` methods.
 * ```ts
 * NbDateFnsDateModule.forRoot({
 *   parseOptions: { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true },
 *   formatOptions: { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true },
 * })
 * ```
 * Further info on `date-fns` formatting tokens could be found at
 * [date-fns docs](https://date-fns.org/v2.0.0-alpha.27/docs/Unicode-Tokens).
 *
 * You can also use `parseOptions` and `formatOptions` to provide locale.
 * ```ts
 * import { eo } from 'date-fns/locale';
 *
 * @NgModule({
 *   imports: [
 *     NbDateFnsDateModule.forRoot({
 *       parseOptions: { locale: eo },
 *       formatOptions: { locale: eo },
 *     }),
 *   ],
 * })
 * ```
 *
 * @styles
 *
 * datepicker-background-color:
 * datepicker-border-color:
 * datepicker-border-style:
 * datepicker-border-width:
 * datepicker-border-radius:
 * datepicker-shadow:
 * */
export declare class NbDatepickerDirective<D> implements OnDestroy, ControlValueAccessor, Validator {
    protected document: any;
    protected datepickerAdapters: NbDatepickerAdapter<D>[];
    protected hostRef: ElementRef;
    protected dateService: NbDateService<D>;
    protected changeDetector: ChangeDetectorRef;
    /**
     * Provides datepicker component.
     * */
    set setPicker(picker: NbDatepicker<D>);
    /**
     * Datepicker adapter.
     * */
    protected datepickerAdapter: NbDatepickerAdapter<D>;
    /**
     * Datepicker instance.
     * */
    protected picker: NbDatepicker<D>;
    protected destroy$: Subject<void>;
    protected isDatepickerReady: boolean;
    protected queue: D | undefined;
    protected onChange: (D: any) => void;
    protected onTouched: () => void;
    /**
     * Form control validators will be called in validators context, so, we need to bind them.
     * */
    protected validator: ValidatorFn;
    constructor(document: any, datepickerAdapters: NbDatepickerAdapter<D>[], hostRef: ElementRef, dateService: NbDateService<D>, changeDetector: ChangeDetectorRef);
    /**
     * Returns html input element.
     * */
    get input(): HTMLInputElement;
    /**
     * Returns host input value.
     * */
    get inputValue(): string;
    ngOnDestroy(): void;
    /**
     * Writes value in picker and html input element.
     * */
    writeValue(value: D): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    /**
     * Form control validation based on picker validator config.
     * */
    validate(): ValidationErrors | null;
    /**
     * Hides picker, focuses the input
     */
    protected hidePicker(): void;
    /**
     * Validates that we can parse value correctly.
     * */
    protected parseValidator(): ValidationErrors | null;
    /**
     * Validates passed value is greater than min.
     * */
    protected minValidator(): ValidationErrors | null;
    /**
     * Validates passed value is smaller than max.
     * */
    protected maxValidator(): ValidationErrors | null;
    /**
     * Validates passed value satisfy the filter.
     * */
    protected filterValidator(): ValidationErrors | null;
    /**
     * Chooses datepicker adapter based on passed picker component.
     * */
    protected chooseDatepickerAdapter(): void;
    /**
     * Attaches picker to the host input element and subscribes on value changes.
     * */
    protected setupPicker(): void;
    protected writePicker(value: D): void;
    protected writeInput(value: D): void;
    /**
     * Validates if no datepicker adapter provided.
     * */
    protected noDatepickerAdapterProvided(): boolean;
    protected subscribeOnInputChange(): void;
    /**
     * Parses input value and write if it isn't null.
     * */
    protected handleInputChange(value: string): void;
    protected parseInputValue(value: any): D | null;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbDatepickerDirective<any>>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbDatepickerDirective<any>, "input[nbDatepicker]", never, {
    "setPicker": "nbDatepicker";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa1JBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmJEYXRlU2VydmljZSB9IGZyb20gJy4uL2NhbGVuZGFyLWtpdC9zZXJ2aWNlcy9kYXRlLnNlcnZpY2UnO1xuLyoqXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckFkYXB0ZXJgIGluc3RhbmNlcyBwcm92aWRlIHdheSBob3cgdG8gcGFyc2UsIGZvcm1hdCBhbmQgdmFsaWRhdGVcbiAqIGRpZmZlcmVudCBkYXRlIHR5cGVzLlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIE5iRGF0ZXBpY2tlckFkYXB0ZXI8RD4ge1xuICAgIC8qKlxuICAgICAqIFBpY2tlciBjb21wb25lbnQgY2xhc3MuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBwaWNrZXI6IFR5cGU8YW55PjtcbiAgICAvKipcbiAgICAgKiBQYXJzZSBkYXRlIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IHBhcnNlKHZhbHVlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogRDtcbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGZvcm1hdCh2YWx1ZTogRCwgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGRhdGUgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGlzVmFsaWQodmFsdWU6IHN0cmluZywgZm9ybWF0OiBzdHJpbmcpOiBib29sZWFuO1xufVxuLyoqXG4gKiBWYWxpZGF0b3JzIGNvbmZpZyB0aGF0IHdpbGwgYmUgdXNlZCBieSBmb3JtIGNvbnRyb2wgdG8gcGVyZm9ybSBwcm9wZXIgdmFsaWRhdGlvbi5cbiAqICovXG5leHBvcnQgaW50ZXJmYWNlIE5iUGlja2VyVmFsaWRhdG9yQ29uZmlnPEQ+IHtcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGRhdGUgYXZhaWxhYmxlIGluIHBpY2tlci5cbiAgICAgKiAqL1xuICAgIG1pbjogRDtcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIGRhdGUgYXZhaWxhYmxlIGluIHBpY2tlci5cbiAgICAgKiAqL1xuICAgIG1heDogRDtcbiAgICAvKipcbiAgICAgKiBQcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzIGlzIHZhbHVlIGF2YWlsYWJsZSBmb3IgcGlja2luZy5cbiAgICAgKiAqL1xuICAgIGZpbHRlcjogKEQ6IGFueSkgPT4gYm9vbGVhbjtcbn1cbi8qKlxuICogRGF0ZXBpY2tlciBpcyBhbiBjb250cm9sIHRoYXQgY2FuIHBpY2sgYW55IHZhbHVlcyBhbnl3YXkuXG4gKiBJdCBoYXMgdG8gYmUgYm91bmQgdG8gdGhlIGRhdGVwaWNrZXIgZGlyZWN0aXZlIHRocm91Z2ggbmJEYXRlcGlja2VyIGlucHV0LlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIE5iRGF0ZXBpY2tlcjxUPiB7XG4gICAgLyoqXG4gICAgICogSFRNTCBpbnB1dCBlbGVtZW50IGRhdGUgZm9ybWF0LlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgZm9ybWF0OiBzdHJpbmc7XG4gICAgYWJzdHJhY3QgZ2V0IHZhbHVlKCk6IFQ7XG4gICAgYWJzdHJhY3Qgc2V0IHZhbHVlKHZhbHVlOiBUKTtcbiAgICBhYnN0cmFjdCBnZXQgdmFsdWVDaGFuZ2UoKTogT2JzZXJ2YWJsZTxUPjtcbiAgICBhYnN0cmFjdCBnZXQgaW5pdCgpOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGRhdGVwaWNrZXIgdG8gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50LlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgYXR0YWNoKGhvc3RSZWY6IEVsZW1lbnRSZWYpOiBhbnk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWxpZGF0b3IgY29uZmlndXJhdGlvbiBiYXNlZCBvbiB0aGUgaW5wdXQgcHJvcGVydGllcy5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGdldFZhbGlkYXRvckNvbmZpZygpOiBOYlBpY2tlclZhbGlkYXRvckNvbmZpZzxUPjtcbiAgICBhYnN0cmFjdCBzaG93KCk6IGFueTtcbiAgICBhYnN0cmFjdCBoaWRlKCk6IGFueTtcbiAgICBhYnN0cmFjdCBzaG91bGRIaWRlKCk6IGJvb2xlYW47XG4gICAgYWJzdHJhY3QgZ2V0IGlzU2hvd24oKTogYm9vbGVhbjtcbiAgICBhYnN0cmFjdCBnZXQgYmx1cigpOiBPYnNlcnZhYmxlPHZvaWQ+O1xufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgTkJfREFURV9BREFQVEVSOiBJbmplY3Rpb25Ub2tlbjxOYkRhdGVwaWNrZXJBZGFwdGVyPGFueT4+O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgTkJfREFURV9TRVJWSUNFX09QVElPTlM6IEluamVjdGlvblRva2VuPHVua25vd24+O1xuLyoqXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckRpcmVjdGl2ZWAgaXMgZm9ybSBjb250cm9sIHRoYXQgZ2l2ZXMgeW91IGFiaWxpdHkgdG8gc2VsZWN0IGRhdGVzIGFuZCByYW5nZXMuIFRoZSBkYXRlcGlja2VyXG4gKiBpcyBzaG93biB3aGVuIGlucHV0IHJlY2VpdmVzIGEgYGZvY3VzYCBldmVudC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgW25iRGF0ZXBpY2tlcl09XCJkYXRlcGlja2VyXCI+XG4gKiA8bmItZGF0ZXBpY2tlciAjZGF0ZXBpY2tlcj48L25iLWRhdGVwaWNrZXI+XG4gKiBgYGBcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBkYXRlcGlja2VyL2RhdGVwaWNrZXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iRGF0ZXBpY2tlck1vZHVsZS5mb3JSb290KClgIHRvIHlvdXIgcm9vdCBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iRGF0ZXBpY2tlck1vZHVsZS5mb3JSb290KCksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICogQW5kIGBOYkRhdGVwaWNrZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iRGF0ZXBpY2tlck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIHJhbmdlIHNlbGVjdGlvbiwgeW91IGhhdmUgdG8gdXNlIGBOYlJhbmdlcGlja2VyQ29tcG9uZW50YCBpbnN0ZWFkOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cInJhbmdlcGlja2VyXCI+XG4gKiA8bmItcmFuZ2VwaWNrZXIgI3JhbmdlcGlja2VyPjwvbmItcmFuZ2VwaWNrZXI+XG4gKiBgYGBcbiAqXG4gKiBCb3RoIHJhbmdlIGFuZCBkYXRlIHBpY2tlcnMgc3VwcG9ydCBhbGwgcGFyYW1ldGVycyBhcyBjYWxlbmRhciwgc28sIGNoZWNrIGBOYkNhbGVuZGFyQ29tcG9uZW50YCBmb3IgYWRkaXRpb25hbFxuICogaW5mby5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFJhbmdlIHNob3djYXNlLCBkYXRlcGlja2VyL3JhbmdlcGlja2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBEYXRlcGlja2VyIGlzIHRoZSBmb3JtIGNvbnRyb2wgc28gaXQgY2FuIGJlIGJvdW5kIHdpdGggYW5ndWxhciBmb3JtcyB0aHJvdWdoIG5nTW9kZWwgYW5kIGZvcm0gY29udHJvbHMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShGb3JtcywgZGF0ZXBpY2tlci9kYXRlcGlja2VyLWZvcm1zLmNvbXBvbmVudClcbiAqXG4gKiBgTmJEYXRlcGlja2VyRGlyZWN0aXZlYCBtYXkgYmUgdmFsaWRhdGVkIHVzaW5nIGBtaW5gIGFuZCBgbWF4YCBkYXRlcyBwYXNzZWQgdG8gdGhlIGRhdGVwaWNrZXIuXG4gKiBBbmQgYGZpbHRlcmAgcHJlZGljYXRlIHRoYXQgcmVjZWl2ZXMgZGF0ZSBvYmplY3QgYW5kIGhhcyB0byByZXR1cm4gYSBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVmFsaWRhdGlvbiwgZGF0ZXBpY2tlci9kYXRlcGlja2VyLXZhbGlkYXRpb24uY29tcG9uZW50KVxuICpcbiAqIFRoZSBgTmJEYXRlcGlja2VyQ29tcG9uZW50YCBzdXBwb3J0cyBkYXRlIGZvcm1hdHRpbmc6XG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYkRhdGVwaWNrZXJdPVwiZGF0ZXBpY2tlclwiPlxuICogPG5iLWRhdGVwaWNrZXIgI2RhdGVwaWNrZXIgZm9ybWF0PVwiTU1cXGRkXFx5eXl5XCI+PC9uYi1kYXRlcGlja2VyPlxuICogYGBgXG4gKlxuICogIyMgRm9ybWF0dGluZyBJc3N1ZVxuICpcbiAqIEJ5IGRlZmF1bHQsIGRhdGVwaWNrZXIgdXNlcyBhbmd1bGFycyBgTE9DQUxFX0lEYCB0b2tlbiBmb3IgbG9jYWxpemF0aW9uIGFuZCBgRGF0ZVBpcGVgIGZvciBkYXRlcyBmb3JtYXR0aW5nLlxuICogQW5kIG5hdGl2ZSBgRGF0ZS5wYXJzZSguLi4pYCBmb3IgZGF0ZXMgcGFyc2luZy4gQnV0IG5hdGl2ZSBgRGF0ZS5wYXJzZWAgZnVuY3Rpb24gZG9lc24ndCBzdXBwb3J0IGZvcm1hdHMuXG4gKiBUbyBwcm92aWRlIGN1c3RvbSBmb3JtYXR0aW5nIHlvdSBoYXZlIHRvIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBwYWNrYWdlczpcbiAqXG4gKiAtIGBAbmVidWxhci9tb21lbnRgIC0gcHJvdmlkZXMgbW9tZW50IGRhdGUgYWRhcHRlciB0aGF0IHVzZXMgbW9tZW50IGZvciBkYXRlIG9iamVjdHMuIFRoaXMgbWVhbnMgZGF0ZXBpY2tlciB0aGFuXG4gKiB3aWxsIG9wZXJhdGUgb25seSBtb21lbnQgZGF0ZSBvYmplY3RzLiBJZiB5b3Ugd2FudCB0byB1c2UgaXQgeW91IGhhdmUgdG8gaW5zdGFsbCBpdDogYG5wbSBpIEBuZWJ1bGFyL21vbWVudGAsIGFuZFxuICogaW1wb3J0IGBOYk1vbWVudERhdGVNb2R1bGVgIGZyb20gdGhpcyBwYWNrYWdlLlxuICpcbiAqIC0gYEBuZWJ1bGFyL2RhdGUtZm5zYCAtIGFkYXB0ZXIgZm9yIHBvcHVsYXIgZGF0ZS1mbnMgbGlicmFyeS4gVGhpcyB3YXkgaXMgcHJlZmVycmVkIGlmIHlvdSBuZWVkIG9ubHkgZGF0ZSBmb3JtYXR0aW5nLlxuICogQmVjYXVzZSBkYXRlLWZucyBpcyB0cmVlc2hha2FibGUsIHRpbnkgYW5kIG9wZXJhdGVzIG5hdGl2ZSBkYXRlIG9iamVjdHMuIElmIHlvdSB3YW50IHRvIHVzZSBpdCB5b3UgaGF2ZSB0b1xuICogaW5zdGFsbCBpdDogYG5wbSBpIEBuZWJ1bGFyL2RhdGUtZm5zYCwgYW5kIGltcG9ydCBgTmJEYXRlRm5zRGF0ZU1vZHVsZWAgZnJvbSB0aGlzIHBhY2thZ2UuXG4gKlxuICogIyMjIE5iRGF0ZUZuc0RhdGVNb2R1bGVcbiAqXG4gKiBGb3JtYXQgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBgTmJEYXRlRm5zRGF0ZU1vZHVsZWAuIFlvdSBjYW4gc2V0IGl0IHZpYSBgZm9ybWF0YCBpbnB1dCBvbiBkYXRlcGlja2VyIGNvbXBvbmVudDpcbiAqIGBgYGh0bWxcbiAqIDxuYi1kYXRlcGlja2VyIGZvcm1hdD1cImRkLk1NLnl5eXlcIj48L25iLWRhdGVwaWNrZXI+XG4gKiBgYGBcbiAqIEFsc28gZm9ybWF0IGNhbiBiZSBzZXQgZ2xvYmFsbHkgd2l0aCBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHsgZm9ybWF0OiAnZGQuTU0ueXl5eScgfSlgIGFuZFxuICogYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yQ2hpbGQoeyBmb3JtYXQ6ICdkZC5NTS55eXl5JyB9KWAgbWV0aG9kcy5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0byB1c2Ugc29tZSBvZiB0aGUgZm9ybWF0dGluZyB0b2tlbnMgeW91IGFsc28gbmVlZCB0byBwYXNzXG4gKiBgeyB1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM6IHRydWUsIHVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM6IHRydWUgfWAgdG8gZGF0ZS1mbnMgcGFyc2UgYW5kIGZvcm1hdCBmdW5jdGlvbnMuXG4gKiBZb3UgY2FuIGNvbmZpZ3VyZSBvcHRpb25zIHBhc3NlZCB0aGlzIGZ1bmN0aW9ucyBieSBzZXR0aW5nIGBmb3JtYXRPcHRpb25zYCBhbmRcbiAqIGBwYXJzZU9wdGlvbnNgIG9mIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290YCBhbmQgYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yQ2hpbGRgIG1ldGhvZHMuXG4gKiBgYGB0c1xuICogTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHtcbiAqICAgcGFyc2VPcHRpb25zOiB7IHVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VuczogdHJ1ZSwgdXNlQWRkaXRpb25hbERheU9mWWVhclRva2VuczogdHJ1ZSB9LFxuICogICBmb3JtYXRPcHRpb25zOiB7IHVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VuczogdHJ1ZSwgdXNlQWRkaXRpb25hbERheU9mWWVhclRva2VuczogdHJ1ZSB9LFxuICogfSlcbiAqIGBgYFxuICogRnVydGhlciBpbmZvIG9uIGBkYXRlLWZuc2AgZm9ybWF0dGluZyB0b2tlbnMgY291bGQgYmUgZm91bmQgYXRcbiAqIFtkYXRlLWZucyBkb2NzXShodHRwczovL2RhdGUtZm5zLm9yZy92Mi4wLjAtYWxwaGEuMjcvZG9jcy9Vbmljb2RlLVRva2VucykuXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSBgcGFyc2VPcHRpb25zYCBhbmQgYGZvcm1hdE9wdGlvbnNgIHRvIHByb3ZpZGUgbG9jYWxlLlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVvIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcbiAqXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHtcbiAqICAgICAgIHBhcnNlT3B0aW9uczogeyBsb2NhbGU6IGVvIH0sXG4gKiAgICAgICBmb3JtYXRPcHRpb25zOiB7IGxvY2FsZTogZW8gfSxcbiAqICAgICB9KSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogZGF0ZXBpY2tlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogZGF0ZXBpY2tlci1ib3JkZXItY29sb3I6XG4gKiBkYXRlcGlja2VyLWJvcmRlci1zdHlsZTpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLXdpZHRoOlxuICogZGF0ZXBpY2tlci1ib3JkZXItcmFkaXVzOlxuICogZGF0ZXBpY2tlci1zaGFkb3c6XG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJEYXRlcGlja2VyRGlyZWN0aXZlPEQ+IGltcGxlbWVudHMgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcbiAgICBwcm90ZWN0ZWQgZG9jdW1lbnQ6IGFueTtcbiAgICBwcm90ZWN0ZWQgZGF0ZXBpY2tlckFkYXB0ZXJzOiBOYkRhdGVwaWNrZXJBZGFwdGVyPEQ+W107XG4gICAgcHJvdGVjdGVkIGhvc3RSZWY6IEVsZW1lbnRSZWY7XG4gICAgcHJvdGVjdGVkIGRhdGVTZXJ2aWNlOiBOYkRhdGVTZXJ2aWNlPEQ+O1xuICAgIHByb3RlY3RlZCBjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgZGF0ZXBpY2tlciBjb21wb25lbnQuXG4gICAgICogKi9cbiAgICBzZXQgc2V0UGlja2VyKHBpY2tlcjogTmJEYXRlcGlja2VyPEQ+KTtcbiAgICAvKipcbiAgICAgKiBEYXRlcGlja2VyIGFkYXB0ZXIuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgZGF0ZXBpY2tlckFkYXB0ZXI6IE5iRGF0ZXBpY2tlckFkYXB0ZXI8RD47XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBpbnN0YW5jZS5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBwaWNrZXI6IE5iRGF0ZXBpY2tlcjxEPjtcbiAgICBwcm90ZWN0ZWQgZGVzdHJveSQ6IFN1YmplY3Q8dm9pZD47XG4gICAgcHJvdGVjdGVkIGlzRGF0ZXBpY2tlclJlYWR5OiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBxdWV1ZTogRCB8IHVuZGVmaW5lZDtcbiAgICBwcm90ZWN0ZWQgb25DaGFuZ2U6IChEOiBhbnkpID0+IHZvaWQ7XG4gICAgcHJvdGVjdGVkIG9uVG91Y2hlZDogKCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBGb3JtIGNvbnRyb2wgdmFsaWRhdG9ycyB3aWxsIGJlIGNhbGxlZCBpbiB2YWxpZGF0b3JzIGNvbnRleHQsIHNvLCB3ZSBuZWVkIHRvIGJpbmQgdGhlbS5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50OiBhbnksIGRhdGVwaWNrZXJBZGFwdGVyczogTmJEYXRlcGlja2VyQWRhcHRlcjxEPltdLCBob3N0UmVmOiBFbGVtZW50UmVmLCBkYXRlU2VydmljZTogTmJEYXRlU2VydmljZTxEPiwgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGh0bWwgaW5wdXQgZWxlbWVudC5cbiAgICAgKiAqL1xuICAgIGdldCBpbnB1dCgpOiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9zdCBpbnB1dCB2YWx1ZS5cbiAgICAgKiAqL1xuICAgIGdldCBpbnB1dFZhbHVlKCk6IHN0cmluZztcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFdyaXRlcyB2YWx1ZSBpbiBwaWNrZXIgYW5kIGh0bWwgaW5wdXQgZWxlbWVudC5cbiAgICAgKiAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IEQpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGb3JtIGNvbnRyb2wgdmFsaWRhdGlvbiBiYXNlZCBvbiBwaWNrZXIgdmFsaWRhdG9yIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIHZhbGlkYXRlKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIEhpZGVzIHBpY2tlciwgZm9jdXNlcyB0aGUgaW5wdXRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaGlkZVBpY2tlcigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHdlIGNhbiBwYXJzZSB2YWx1ZSBjb3JyZWN0bHkuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcGFyc2VWYWxpZGF0b3IoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhc3NlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gbWluLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIG1pblZhbGlkYXRvcigpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFzc2VkIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiBtYXguXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgbWF4VmFsaWRhdG9yKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwYXNzZWQgdmFsdWUgc2F0aXNmeSB0aGUgZmlsdGVyLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGZpbHRlclZhbGlkYXRvcigpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBDaG9vc2VzIGRhdGVwaWNrZXIgYWRhcHRlciBiYXNlZCBvbiBwYXNzZWQgcGlja2VyIGNvbXBvbmVudC5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBjaG9vc2VEYXRlcGlja2VyQWRhcHRlcigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHBpY2tlciB0byB0aGUgaG9zdCBpbnB1dCBlbGVtZW50IGFuZCBzdWJzY3JpYmVzIG9uIHZhbHVlIGNoYW5nZXMuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgc2V0dXBQaWNrZXIoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgd3JpdGVQaWNrZXIodmFsdWU6IEQpOiB2b2lkO1xuICAgIHByb3RlY3RlZCB3cml0ZUlucHV0KHZhbHVlOiBEKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgaWYgbm8gZGF0ZXBpY2tlciBhZGFwdGVyIHByb3ZpZGVkLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIG5vRGF0ZXBpY2tlckFkYXB0ZXJQcm92aWRlZCgpOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBzdWJzY3JpYmVPbklucHV0Q2hhbmdlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGlucHV0IHZhbHVlIGFuZCB3cml0ZSBpZiBpdCBpc24ndCBudWxsLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBwYXJzZUlucHV0VmFsdWUodmFsdWU6IGFueSk6IEQgfCBudWxsO1xufVxuIl19