import { DoCheck, IterableDiffer, IterableDiffers, NgZone, OnDestroy, OnInit } from '@angular/core';
import { Layer } from 'leaflet';
import { LeafletDirective } from '../core/leaflet.directive';
/**
 * Layers directive
 *
 * This directive is used to directly control map layers. As changes are made to the input array of
 * layers, the map is synched to the array. As layers are added or removed from the input array, they
 * are also added or removed from the map. The input array is treated as immutable. To detect changes,
 * you must change the array instance.
 *
 * Important Note: The input layers array is assumed to be immutable. This means you need to use an
 * immutable array implementation or create a new copy of your array when you make changes, otherwise
 * this directive won't detect the change. This is by design. It's for performance reasons. Change
 * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which
 * is extremely expensive from a time complexity perspective.
 *
 */
import * as ɵngcc0 from '@angular/core';
export declare class LeafletLayersDirective implements DoCheck, OnDestroy, OnInit {
    private differs;
    private zone;
    layersValue: Layer[];
    layersDiffer: IterableDiffer<Layer>;
    layers: Layer[];
    private leafletDirective;
    constructor(leafletDirective: LeafletDirective, differs: IterableDiffers, zone: NgZone);
    ngDoCheck(): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    /**
     * Update the state of the layers.
     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
     * This is important because it allows us to react to changes to the contents of the array as well
     * as changes to the actual array instance.
     */
    private updateLayers();
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LeafletLayersDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<LeafletLayersDirective, "[leafletLayers]", never, {
    "layers": "leafletLayers";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVhZmxldC1sYXllcnMuZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImxlYWZsZXQtbGF5ZXJzLmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRG9DaGVjaywgSXRlcmFibGVEaWZmZXIsIEl0ZXJhYmxlRGlmZmVycywgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICdsZWFmbGV0JztcbmltcG9ydCB7IExlYWZsZXREaXJlY3RpdmUgfSBmcm9tICcuLi9jb3JlL2xlYWZsZXQuZGlyZWN0aXZlJztcbi8qKlxuICogTGF5ZXJzIGRpcmVjdGl2ZVxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIHVzZWQgdG8gZGlyZWN0bHkgY29udHJvbCBtYXAgbGF5ZXJzLiBBcyBjaGFuZ2VzIGFyZSBtYWRlIHRvIHRoZSBpbnB1dCBhcnJheSBvZlxuICogbGF5ZXJzLCB0aGUgbWFwIGlzIHN5bmNoZWQgdG8gdGhlIGFycmF5LiBBcyBsYXllcnMgYXJlIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgaW5wdXQgYXJyYXksIHRoZXlcbiAqIGFyZSBhbHNvIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgbWFwLiBUaGUgaW5wdXQgYXJyYXkgaXMgdHJlYXRlZCBhcyBpbW11dGFibGUuIFRvIGRldGVjdCBjaGFuZ2VzLFxuICogeW91IG11c3QgY2hhbmdlIHRoZSBhcnJheSBpbnN0YW5jZS5cbiAqXG4gKiBJbXBvcnRhbnQgTm90ZTogVGhlIGlucHV0IGxheWVycyBhcnJheSBpcyBhc3N1bWVkIHRvIGJlIGltbXV0YWJsZS4gVGhpcyBtZWFucyB5b3UgbmVlZCB0byB1c2UgYW5cbiAqIGltbXV0YWJsZSBhcnJheSBpbXBsZW1lbnRhdGlvbiBvciBjcmVhdGUgYSBuZXcgY29weSBvZiB5b3VyIGFycmF5IHdoZW4geW91IG1ha2UgY2hhbmdlcywgb3RoZXJ3aXNlXG4gKiB0aGlzIGRpcmVjdGl2ZSB3b24ndCBkZXRlY3QgdGhlIGNoYW5nZS4gVGhpcyBpcyBieSBkZXNpZ24uIEl0J3MgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIENoYW5nZVxuICogZGV0ZWN0aW9uIG9mIG11dGFibGUgYXJyYXlzIHJlcXVpcmVzIGRpZmZpbmcgdGhlIHN0YXRlIG9mIHRoZSBhcnJheSBvbiBldmVyeSBEb0NoZWNrIGN5Y2xlLCB3aGljaFxuICogaXMgZXh0cmVtZWx5IGV4cGVuc2l2ZSBmcm9tIGEgdGltZSBjb21wbGV4aXR5IHBlcnNwZWN0aXZlLlxuICpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTGVhZmxldExheWVyc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIERvQ2hlY2ssIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgICBwcml2YXRlIGRpZmZlcnM7XG4gICAgcHJpdmF0ZSB6b25lO1xuICAgIGxheWVyc1ZhbHVlOiBMYXllcltdO1xuICAgIGxheWVyc0RpZmZlcjogSXRlcmFibGVEaWZmZXI8TGF5ZXI+O1xuICAgIGxheWVyczogTGF5ZXJbXTtcbiAgICBwcml2YXRlIGxlYWZsZXREaXJlY3RpdmU7XG4gICAgY29uc3RydWN0b3IobGVhZmxldERpcmVjdGl2ZTogTGVhZmxldERpcmVjdGl2ZSwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCB6b25lOiBOZ1pvbmUpO1xuICAgIG5nRG9DaGVjaygpOiB2b2lkO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBsYXllcnMuXG4gICAgICogV2UgdXNlIGFuIGl0ZXJhYmxlIGRpZmZlciB0byBzeW5jaHJvbml6ZSB0aGUgbWFwIGxheWVycyB3aXRoIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgbGF5ZXJzIGFycmF5LlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgaXQgYWxsb3dzIHVzIHRvIHJlYWN0IHRvIGNoYW5nZXMgdG8gdGhlIGNvbnRlbnRzIG9mIHRoZSBhcnJheSBhcyB3ZWxsXG4gICAgICogYXMgY2hhbmdlcyB0byB0aGUgYWN0dWFsIGFycmF5IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlTGF5ZXJzKCk7XG59XG4iXX0=